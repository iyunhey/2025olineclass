import streamlit as st
import plotly.graph_objects as go
from collections import deque

# --- í˜ì´ì§€ ì„¤ì • ---
st.set_page_config(page_title="ìë£Œêµ¬ì¡°: ìŠ¤íƒê³¼ í", layout="wide")

st.title("ğŸ“š ìë£Œêµ¬ì¡°: ìŠ¤íƒ(Stack)ê³¼ í(Queue) ğŸ“š")
st.markdown("ìŠ¤íƒê³¼ íëŠ” ì»´í“¨í„° ê³¼í•™ì—ì„œ ë°ì´í„°ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê¸° ìœ„í•œ ê¸°ë³¸ì ì¸ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. ê° ìë£Œêµ¬ì¡°ì˜ íŠ¹ì§•ê³¼ ë™ì‘ ë°©ì‹ì„ ì‹œê°ì ìœ¼ë¡œ ì‚´í´ë³´ì„¸ìš”.")

# --- ìŠ¤íƒ ì„¹ì…˜ ---
st.header("1. ìŠ¤íƒ (Stack)")
st.subheader("ê°œë…: LIFO (Last In, First Out)")
st.markdown(
    """
    ìŠ¤íƒì€ **ê°€ì¥ ë‚˜ì¤‘ì— ë“¤ì–´ì˜¨ ìš”ì†Œê°€ ê°€ì¥ ë¨¼ì € ë‚˜ê°€ëŠ” (Last In, First Out - LIFO)** êµ¬ì¡°ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
    ë§ˆì¹˜ ìŒ“ì—¬ìˆëŠ” ì ‘ì‹œ ë”ë¯¸ì™€ ê°™ìŠµë‹ˆë‹¤. ê°€ì¥ ìœ„ì— ìˆëŠ” ì ‘ì‹œë¥¼ ë¨¼ì € êº¼ë‚´ì•¼ ì•„ë˜ì— ìˆëŠ” ì ‘ì‹œë¥¼ êº¼ë‚¼ ìˆ˜ ìˆì£ .

    **ì£¼ìš” ì—°ì‚°:**
    -   `push`: ìŠ¤íƒì˜ ë§¨ ìœ„ì— ìš”ì†Œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
    -   `pop`: ìŠ¤íƒì˜ ë§¨ ìœ„ ìš”ì†Œë¥¼ ì œê±°í•˜ê³  ë°˜í™˜í•©ë‹ˆë‹¤.
    -   `peek` (ë˜ëŠ” `top`): ìŠ¤íƒì˜ ë§¨ ìœ„ ìš”ì†Œë¥¼ ë°˜í™˜í•˜ì§€ë§Œ ì œê±°í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤.
    -   `isEmpty`: ìŠ¤íƒì´ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    """
)

# ìŠ¤íƒ ìƒíƒœ ê´€ë¦¬
if 'stack' not in st.session_state:
    st.session_state.stack = []

# ìŠ¤íƒ ì‹œê°í™” í•¨ìˆ˜
def plot_stack(stack_data):
    if not stack_data:
        fig = go.Figure()
        fig.add_annotation(
            text="ìŠ¤íƒì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.",
            xref="paper", yref="paper",
            x=0.5, y=0.5, showarrow=False,
            font=dict(size=20, color="gray")
        )
        fig.update_layout(
            height=300,
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            margin=dict(l=20, r=20, t=20, b=20),
            plot_bgcolor='rgba(0,0,0,0)'
        )
        return fig

    # ìŠ¤íƒ ì‹œê°í™”ë¥¼ ìœ„í•œ ë°ì´í„° ì¤€ë¹„ (ìˆ˜ì§ ìŠ¤íƒ)
    # x_valuesëŠ” ëª¨ë“  ë°”ì˜ x ìœ„ì¹˜ë¥¼ ì¤‘ì•™ìœ¼ë¡œ ì„¤ì •
    x_values = [0.5] * len(stack_data)
    # y_valuesëŠ” ë°”ì˜ ìˆ˜ì§ ìœ„ì¹˜ (ì¸ë±ìŠ¤)
    y_values = list(range(len(stack_data)))
    # y_labelsëŠ” yì¶•ì— í‘œì‹œë  ë ˆì´ë¸” (ì˜ˆ: [0] ê°’1, [1] ê°’2)
    y_labels = [f"[{i}] {val}" for i, val in enumerate(stack_data)]

    fig = go.Figure(
        data=[
            go.Bar(
                x=x_values, # xì¶•ì€ ê³ ì •í•˜ê³ 
                y=y_values, # yì¶•ìœ¼ë¡œ ë°”ì˜ ë†’ì´ë¥¼ ì¡°ì ˆí•˜ì—¬ ìˆ˜ì§ ìŠ¤íƒì²˜ëŸ¼ ë³´ì´ê²Œ í•©ë‹ˆë‹¤.
                marker_color='skyblue',
                text=stack_data,
                textposition='auto',
                hoverinfo='text'
            )
        ]
    )
    fig.update_layout(
        title_text="í˜„ì¬ ìŠ¤íƒ ìƒíƒœ",
        title_x=0.5,
        height=max(300, len(stack_data) * 50 + 100), # ìŠ¤íƒ í¬ê¸°ì— ë”°ë¼ ë†’ì´ ì¡°ì ˆ
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False), # xì¶• ë ˆì´ë¸” ìˆ¨ê¹€
        yaxis=dict(
            tickmode='array',
            tickvals=y_values,
            ticktext=y_labels,
            autorange="reversed" # ìŠ¤íƒì²˜ëŸ¼ ìœ„ë¡œ ìŒ“ì´ë„ë¡ (ê°€ì¥ ìµœê·¼ ìš”ì†Œê°€ ìœ„)
        ),
        margin=dict(l=50, r=50, t=50, b=50),
        plot_bgcolor='rgba(0,0,0,0)'
    )
    return fig

# ìŠ¤íƒ ì¸í„°í˜ì´ìŠ¤
col_stack_input, col_stack_buttons = st.columns([1, 2])

with col_stack_input:
    stack_value = st.text_input("ìŠ¤íƒì— ì¶”ê°€í•  ê°’:", key="stack_input")

with col_stack_buttons:
    st.write("") # ê³µê°„ í™•ë³´
    st.write("") # ê³µê°„ í™•ë³´
    if st.button("â• Push (ì¶”ê°€)", key="push_button"):
        if stack_value:
            st.session_state.stack.append(stack_value)
            st.success(f"'{stack_value}'ë¥¼ ìŠ¤íƒì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.")
            st.session_state.stack_input = "" # ì…ë ¥ì°½ ì´ˆê¸°í™”
        else:
            st.warning("ì¶”ê°€í•  ê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")

    if st.button("â– Pop (ì œê±°)", key="pop_button"):
        if st.session_state.stack:
            popped_value = st.session_state.stack.pop()
            st.info(f"'{popped_value}'ë¥¼ ìŠ¤íƒì—ì„œ ì œê±°í–ˆìŠµë‹ˆë‹¤.")
        else:
            st.error("ìŠ¤íƒì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. ì œê±°í•  ìš”ì†Œê°€ ì—†ìŠµë‹ˆë‹¤.")

st.plotly_chart(plot_stack(st.session_state.stack), use_container_width=True)

st.markdown("---")

# --- í ì„¹ì…˜ ---
st.header("2. í (Queue)")
st.subheader("ê°œë…: FIFO (First In, First Out)")
st.markdown(
    """
    íëŠ” **ê°€ì¥ ë¨¼ì € ë“¤ì–´ì˜¨ ìš”ì†Œê°€ ê°€ì¥ ë¨¼ì € ë‚˜ê°€ëŠ” (First In, First Out - FIFO)** êµ¬ì¡°ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
    ì€í–‰ì´ë‚˜ ë§ˆíŠ¸ì˜ ì¤„ê³¼ ê°™ìŠµë‹ˆë‹¤. ë¨¼ì € ì¤„ì„ ì„  ì‚¬ëŒì´ ë¨¼ì € ì„œë¹„ìŠ¤ë¥¼ ë°›ì£ .

    **ì£¼ìš” ì—°ì‚°:**
    -   `enqueue` (ë˜ëŠ” `offer`): íì˜ ë’¤ìª½ì— ìš”ì†Œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
    -   `dequeue` (ë˜ëŠ” `poll`): íì˜ ì•ìª½ ìš”ì†Œë¥¼ ì œê±°í•˜ê³  ë°˜í™˜í•©ë‹ˆë‹¤.
    -   `front` (ë˜ëŠ” `peek`): íì˜ ì•ìª½ ìš”ì†Œë¥¼ ë°˜í™˜í•˜ì§€ë§Œ ì œê±°í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤.
    -   `rear`: íì˜ ë’¤ìª½ ìš”ì†Œë¥¼ ë°˜í™˜í•˜ì§€ë§Œ ì œê±°í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤.
    -   `isEmpty`: íê°€ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    """
)

# í ìƒíƒœ ê´€ë¦¬
if 'queue' not in st.session_state:
    st.session_state.queue = deque() # dequeëŠ” í ì—°ì‚°ì— íš¨ìœ¨ì 

# í ì‹œê°í™” í•¨ìˆ˜
def plot_queue(queue_data):
    if not queue_data:
        fig = go.Figure()
        fig.add_annotation(
            text="íê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.",
            xref="paper", yref="paper",
            x=0.5, y=0.5, showarrow=False,
            font=dict(size=20, color="gray")
        )
        fig.update_layout(
            height=300,
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            margin=dict(l=20, r=20, t=20, b=20),
            plot_bgcolor='rgba(0,0,0,0)'
        )
        return fig

    # í ì‹œê°í™”ë¥¼ ìœ„í•œ ë°ì´í„° ì¤€ë¹„
    x_labels = [f"{val}" for val in queue_data]
    x_values = list(range(len(queue_data)))

    fig = go.Figure(
        data=[
            go.Bar(
                x=x_values,
                y=[1] * len(queue_data), # ëª¨ë“  ë°”ì˜ ë†’ì´ë¥¼ ë™ì¼í•˜ê²Œ
                marker_color='lightcoral',
                text=queue_data,
                textposition='auto',
                hoverinfo='text'
            )
        ]
    )
    fig.update_layout(
        title_text="í˜„ì¬ í ìƒíƒœ",
        title_x=0.5,
        height=300,
        xaxis=dict(
            tickmode='array',
            tickvals=x_values,
            ticktext=x_labels,
            title="â† Dequeue (ì•) | Enqueue (ë’¤) â†’"
        ),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        margin=dict(l=50, r=50, t=50, b=50),
        plot_bgcolor='rgba(0,0,0,0)'
    )
    return fig

# í ì¸í„°í˜ì´ìŠ¤
col_queue_input, col_queue_buttons = st.columns([1, 2])

with col_queue_input:
    queue_value = st.text_input("íì— ì¶”ê°€í•  ê°’:", key="queue_input")

with col_queue_buttons:
    st.write("") # ê³µê°„ í™•ë³´
    st.write("") # ê³µê°„ í™•ë³´
    if st.button("â• Enqueue (ì¶”ê°€)", key="enqueue_button"):
        if queue_value:
            st.session_state.queue.append(queue_value)
            st.success(f"'{queue_value}'ë¥¼ íì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.")
            st.session_state.queue_input = "" # ì…ë ¥ì°½ ì´ˆê¸°í™”
        else:
            st.warning("ì¶”ê°€í•  ê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")

    if st.button("â– Dequeue (ì œê±°)", key="dequeue_button"):
        if st.session_state.queue:
            dequeued_value = st.session_state.queue.popleft() # íì˜ ì•ìª½ì—ì„œ ì œê±°
            st.info(f"'{dequeued_value}'ë¥¼ íì—ì„œ ì œê±°í–ˆìŠµë‹ˆë‹¤.")
        else:
            st.error("íê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. ì œê±°í•  ìš”ì†Œê°€ ì—†ìŠµë‹ˆë‹¤.")

st.plotly_chart(plot_queue(list(st.session_state.queue)), use_container_width=True)

st.markdown("---")
st.markdown("### ğŸ’¡ ë” ì•Œì•„ë³´ê¸°")
st.markdown(
    """
    ìŠ¤íƒê³¼ íëŠ” ë‹¤ì–‘í•œ í”„ë¡œê·¸ë˜ë° ë¬¸ì œ í•´ê²°ì— ì‚¬ìš©ë©ë‹ˆë‹¤.
    ì˜ˆë¥¼ ë“¤ì–´, ì›¹ ë¸Œë¼ìš°ì €ì˜ 'ë’¤ë¡œ ê°€ê¸°' ê¸°ëŠ¥ì€ ìŠ¤íƒì„ ì‚¬ìš©í•˜ê³ ,
    í”„ë¦°í„°ì˜ ì¸ì‡„ ëŒ€ê¸°ì—´ì€ íë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
    """
)
